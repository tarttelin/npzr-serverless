package com.pyruby.npzr.model

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable
import com.fasterxml.jackson.annotation.JsonIgnore
import com.pyruby.npzr.PlayException
import kotlin.random.Random

@DynamoDBTable(tableName="Game")
data class Game(
        @DynamoDBHashKey(attributeName="id") @DynamoDBAutoGeneratedKey var id: String? = null,
        @DynamoDBAttribute(attributeName = "players") var players: List<Player> = emptyList(),
        @DynamoDBAttribute(attributeName = "discardPile") var discardPile: List<Card> = emptyList(),
        @DynamoDBAttribute(attributeName = "deck") @JsonIgnore var deck: List<Card> = emptyList()
) {

    fun join(secondPlayer: String): Game {
        if (player2 != null || players[1].playerType != PlayerType.Player ) {
            throw IllegalStateException("Cannot join this game")
        }
        return startGame(secondPlayer)
    }

    private fun startGame(secondPlayer: String): Game {
        val player1First = Random.nextBoolean()
        if (player1First) {
            return copy(players = listOf(players[0].copy(hand = deck.subList(0, 6), playState = PlayState.Play), players[1].copy(userId = secondPlayer, hand = deck.subList(6, 11))),
                    deck = deck.subList(11, deck.size))
        } else {
            return copy(players = listOf(players[0].copy(hand = deck.subList(0, 5)), players[1].copy(userId = secondPlayer, hand = deck.subList(5, 11), playState = PlayState.Play)),
                    deck = deck.subList(11, deck.size))
        }
    }

    fun playCard(username: String, cardId: String, stackId: String, position: BodyPart): Game {
        val player = activePlayer() ?: throw PlayException("No active player")
        if (player.userId != username) throw PlayException("It is not your play phase")
        val cardToPlay = if (player.playState == PlayState.Play) {
            activePlayer()?.hand?.find { card -> card.id == cardId } ?:
            throw PlayException("Card not in your hand")
        } else {
            if (activePlayer()?.playState !in listOf(PlayState.Move, PlayState.MoveWild)) throw PlayException("Not your turn to move a card")
            players.flatMap { it.stacks }
                    .flatMap { listOf(it.head.firstOrNull(), it.torso.firstOrNull(), it.legs.firstOrNull())}
                    .firstOrNull { it?.id == cardId } ?:
            throw PlayException("Cannot locate card on top of a stack")
        }
        val targetStack = players.flatMap { it.stacks }.find { it.id == stackId } ?: throw PlayException("Unknown stack")
        val updatedStack = targetStack.play(cardToPlay, position)

        val (scoredPlayer, discards) = PlayerScore.completeStacks(player.copy(
                hand=player.hand.filter{ it.id != cardId },
                stacks = updateStacks(player.stacks, updatedStack, cardToPlay)
        ))
        val opponent = players.find { it.userId != username }!!
        val (scoredOpponent, opponentDiscards) = PlayerScore.completeStacks(opponent.copy(
                stacks = updateStacks(opponent.stacks, updatedStack, cardToPlay)))

        val hasCompletedStack = !discards.plus(opponentDiscards).isEmpty()
        val playerStateUpdate = updatePlayerState(scoredPlayer, scoredOpponent, hasCompletedStack, cardToPlay.isWild())
        val opponentStateUpdate = updatePlayerState(scoredOpponent, scoredPlayer, hasCompletedStack, playerStateUpdate.playState != PlayState.Wait)

        return this.copy(
                deck = if (opponentStateUpdate.playState == PlayState.Play) deck.subList(1, deck.size) else deck,
                discardPile = discardPile.plus(discards).plus(opponentDiscards),
                players = players.map { p -> if (p.userId == username) playerStateUpdate else opponentStateUpdate }
        )
    }

    private fun updatePlayerState(player: Player, opponent: Player, hasCompletedStack: Boolean, wild: Boolean): Player {
        return when(player.playState) {
            PlayState.Wait ->
                if (winner(player.completed))
                    player.copy(playState = PlayState.Winner)
                else if (winner(opponent.completed))
                    player.copy(playState = PlayState.Loser)
                else if (hasCompletedStack || wild)
                    player
                else
                    player.copy(playState = PlayState.Play, hand = player.hand.plus(deck.first()))
            PlayState.Move ->
                if (winner(player.completed))
                    player.copy(playState = PlayState.Winner)
                else if (winner(opponent.completed))
                    player.copy(playState = PlayState.Loser)
                else if (hasCompletedStack)
                    player
                else
                    player.copy(playState = PlayState.Wait)
            PlayState.MoveWild ->
                if (winner(player.completed))
                    player.copy(playState = PlayState.Winner)
                else if (winner(opponent.completed))
                    player.copy(playState = PlayState.Loser)
                else if (hasCompletedStack) player
                else if (player.hand.isNotEmpty()) player.copy(playState = PlayState.Play)
                else player.copy(playState = PlayState.Wait)
            PlayState.Play ->
                if (winner(player.completed))
                    player.copy(playState = PlayState.Winner)
                else if (winner(opponent.completed))
                    player.copy(playState = PlayState.Loser)
                else if (hasCompletedStack && wild)
                    player.copy(playState = PlayState.MoveWild)
                else if (hasCompletedStack)
                    player.copy(playState = PlayState.Move)
                else if (wild && player.hand.isNotEmpty())
                    player
                else
                    player.copy(playState = PlayState.Wait)
            PlayState.Loser -> player
            PlayState.Winner -> player
        }
    }

    private fun updateStacks(stacks: List<Stack>, updatedStack: Stack, playedCard: Card): List<Stack> {
        val replacedStacks = stacks.map { stack -> if (stack.id == updatedStack.id) updatedStack else stack }
        val updatedStacks = if (replacedStacks.any { s -> s.head.isEmpty() && s.torso.isEmpty() && s.legs.isEmpty() }) {
            replacedStacks
        } else {
            replacedStacks.plus(Stack())
        }
        return updatedStacks.map {
            if (it.id == updatedStack.id) {
                it
            } else {
                it.copy(
                    head = it.head.filter { c -> c.id != playedCard.id },
                    torso = it.torso.filter { c -> c.id != playedCard.id },
                    legs = it.legs.filter { c -> c.id != playedCard.id }
            )}
        }
    }

    fun activePlayer(): Player? = players.find { p -> p.playState != PlayState.Wait }

    private fun winner(characters: List<String>) = CharacterType.values().toList().map { it.name }.minus(characters).size == 1

    @JsonIgnore
    @DynamoDBAttribute(attributeName="player1")
    var player1: String? = null
        get() = if (players.isNotEmpty()) players[0].userId else null

    @JsonIgnore
    @DynamoDBAttribute(attributeName="player2")
    var player2: String? = null
        get() = if (players.size > 1) players[1].userId else null

    companion object {
        fun createGame(username: String, opponent: PlayerType) : Game {
            val ids = (0..55).shuffled()
            val deck = (0..47).map { idx -> Card("" + ids[idx], BodyPart.values()[idx % 3], CharacterType.values()[idx % 4])}
                .plus( (0..4).map { idx -> Card("" + ids[(idx + 48)], BodyPart.Wild, CharacterType.values()[idx])})
                .plus( (0..2).map { idx -> Card("" + ids[(idx + 53)], BodyPart.values()[idx], CharacterType.Wild)})
            val players = listOf(Player(username), Player(playerType = opponent))
            val game = Game(deck = deck.shuffled(), players = players)
            return if (opponent == PlayerType.AI) {
                game.startGame("Robot player")
            } else {
                game
            }
        }
    }
}