package com.pyruby.npzr.model

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable
import com.fasterxml.jackson.annotation.JsonIgnore
import com.pyruby.npzr.PlayException
import com.pyruby.npzr.playstep.StartPlay
import kotlin.random.Random

@DynamoDBTable(tableName="Game")
data class Game(
        @DynamoDBHashKey(attributeName="id") @DynamoDBAutoGeneratedKey var id: String? = null,
        @DynamoDBAttribute(attributeName = "players") var players: List<Player> = emptyList(),
        @DynamoDBAttribute(attributeName = "discardPile") var discardPile: List<Card> = emptyList(),
        @DynamoDBAttribute(attributeName = "deck") @JsonIgnore var deck: List<Card> = emptyList()
) {

    fun join(secondPlayer: String): Game {
        if (player2 != null || players[1].playerType != PlayerType.Player ) {
            throw IllegalStateException("Cannot join this game")
        }
        return startGame(secondPlayer)
    }

    private fun startGame(secondPlayer: String): Game {
        val player1First = Random.nextBoolean()
        if (player1First) {
            return copy(players = listOf(players[0].copy(hand = deck.subList(0, 6), playState = PlayState.Play), players[1].copy(userId = secondPlayer, hand = deck.subList(6, 11))),
                    deck = deck.subList(11, deck.size))
        } else {
            return copy(players = listOf(players[0].copy(hand = deck.subList(0, 5)), players[1].copy(userId = secondPlayer, hand = deck.subList(5, 11), playState = PlayState.Play)),
                    deck = deck.subList(11, deck.size))
        }
    }

    fun currentPlayer(username: String): StartPlay {
        val player = activePlayer() ?: throw PlayException("No active player")
        if (player.userId != username) throw PlayException("It is not your play phase")
        return StartPlay(this, activePlayer()!!, this.players.find { it.userId != username}!!)
    }

    fun playCard(username: String, cardId: String, stackId: String, position: BodyPart) =
        currentPlayer(username)
                .playCard(cardId)
                .onStackSlot(stackId, position)
                .scoreCompletedStacks()
                .updatePlayState()
                .dealNextCard()
                .ensurePlayersHaveAnEmptyStack()
                .game

    fun activePlayer(): Player? = players.find { p -> p.playState != PlayState.Wait }

    @JsonIgnore
    @DynamoDBAttribute(attributeName="player1")
    var player1: String? = null
        get() = if (players.isNotEmpty()) players[0].userId else null

    @JsonIgnore
    @DynamoDBAttribute(attributeName="player2")
    var player2: String? = null
        get() = if (players.size > 1) players[1].userId else null

    companion object {
        fun createGame(username: String, opponent: PlayerType) : Game {
            val ids = (0..55).shuffled()
            val deck = (0..47).map { idx -> Card("" + ids[idx], BodyPart.values()[idx % 3], CharacterType.values()[idx % 4])}
                .plus( (0..4).map { idx -> Card("" + ids[(idx + 48)], BodyPart.Wild, CharacterType.values()[idx])})
                .plus( (0..2).map { idx -> Card("" + ids[(idx + 53)], BodyPart.values()[idx], CharacterType.Wild)})
            val players = listOf(Player(username), Player(playerType = opponent))
            val game = Game(deck = deck.shuffled(), players = players)
            return if (opponent == PlayerType.AI) {
                game.startGame("Robot player")
            } else {
                game
            }
        }
    }
}

